{
  "date": "Monday January 3rd, 2022",
  "dateshort": "January 3rd",
  "body": "A JavaScript Regular Expression (or **Regex**) is a sequence of characters that we can utilize to work effectively with strings. Using this syntax, we can:\n\n* **search** for text in a string\n* **replace** substrings in a string\n* **extract** information from a string\n\nDating back to the 1950s, Regular Expressions were formalized as a concept for pattern searching in string-processing algorithms.\n\nJavaScript has regular expressions support directly built into the language. A solid understanding of regular expressions will make you a much more effective programmer. So let’s get started!\n\n## A very basic Regex pattern\n\nHere’s a basic pattern:\n\n```\nvar regex = /hello/;\n\nconsole.log(regex.test('hello world'));  \n// true\n```\n\nWe are simply matching the literal text with the test string. We’ll look at the regex test method in detail shortly...\n\n## Why use Regular Expressions?\n\nAs mentioned, Regular Expressions are a way to describe patterns in string data. We can use them to check a string of characters, for example, to look for an e-mail address — by matching the pattern which is defined by our regular expression.\n\n## Creating a Regular Expression\n\nIn JavaScript, we can create a Regular Expression in two ways: Either by using the RegExp constructor or by using forward slashes `/` to enclose the regex pattern.\n\n### The constructor method:\n\nThe syntax is like so:\n\n```\nnew RegExp(pattern[, flags])\n```\n\nSo for example:\n\n```\nlet regexConst = new RegExp('abc');\n```\n\n### The literal method:\n\nThe syntax is like so:\n\n```\n/pattern/flags\n```\n\nAn example:\n\n```\nlet regexLiteral = /abc/;\n```\n\n*Note:* flags are optional, we’ll look at these later in this article!\n\nIn the case where you need to create regular expressions dynamically, you’ll need to use the constructor method.\n\nIn either case, the result will give a regex object — which will have the same methods and properties attached to them, for our use.\n\n## Regular Expression Methods\n\nWhen testing our regular expressions, we generally use one of two methods: `RegExp.prototype.test()` or `RegExp.prototype.exec()`.\n\n### RegExp.prototype.test()\n\nWe use this method to test whether a match has been found or not. It accepts a string which we test against a regular expression and returns either `true`or `false`, depending if the match is found or not.\n\nLet’s see an example:\n\n```\nlet regex = /hello/; \nlet str = 'hello world';\nlet result = regex.test(str);\n\nconsole.log(result); \n// returns 'true' as hello is present in our string\n```\n\n### RegExp.prototype.exec()\n\nWe use this method to receive an array of all the matched groups. It accepts a string that we test against our regular expression.\n\nAn example:\n\n```\nlet regex = /hello/;\nlet str = 'hello world';\nlet result = regex.exec(str);\n\nconsole.log(result);\n// returns [ 'hello', index: 0, input: 'hello world', groups: undefined ]\n```\n\nIn this example, `‘hello’` is our matched pattern, `index` is where the regular expression starts & `input` is the string that was passed.\n\nFor the rest of the article, we’ll be using the `test()` method.\n\n## The Power of Regex\n\nWe’ve so far seen how to create simple regular expression patterns. This is really just the tip of the iceberg. Let’s now take a dive into the syntax to see the full power of regular expressions for handling more complex tasks!\n\nAn example of a more complex task would be if we needed to match a number of email addresses. By using the special characters defined in the syntax — we can achieve this!\n\nLet’s take a look now so we can more fully grasp & therefore utilize regular expressions in our programs.\n\n## Flags:\n\nIn any regular expression, we can use the following flags:\n\n* `g`: matches the pattern multiple times\n* `i`: makes the regex case insensitive\n* `m`: enables multi-line mode. Where `^` and `$` match the start and end of the entire string. Without this, multi-line strings match the beginning and end of each line.\n* `u`: enables support for unicode\n* `s`: short for *single line*, it causes the `.` to also match new line characters\n\nFlags may also be combined in a single regular expression & the flag order doesn’t matter. They are added at the end of the string in regex **literals**:\n\n```\n/hello/ig.test('HEllo')\n// returns true\n```\n\nIf using RegExp object **constructors**, they’re added as the second parameter:\n\n```\nnew RegExp('hello', 'ig').test('HEllo') \n// returns true\n```\n\n## Character groups:\n\n### Character set \\[abc]\n\nWe use character sets to match different characters in a single position. They match any single character in the string with the characters inside the brackets:\n\n```\nlet regex = /[hc]ello/;\n\nconsole.log(regex.test('hello'));\n// returns true\n\nconsole.log(regex.test('cello'));\n// returns true\n\nconsole.log(regex.test('jello'));\n// returns false\n```\n\n### Negated character set [^abc]\n\nIt matches anything that is **not** enclosed in the brackets:\n\n```\nlet regex = /[^hc]ello/;\n\nconsole.log(regex.test('hello'));\n// returns false\n\nconsole.log(regex.test('cello'));\n// returns false\n\nconsole.log(regex.test('jello'));\n// returns true\n```\n\n### Ranges \\[a-z]\n\nIf we want to match **all** of the letters of an alphabet in a single position, we can use ranges. For example: **\\[a-j]** will match all the letters from a to j. We can also use digits like **\\[0–9]** or capital letters like **\\[A-Z]**:\n\n```\nlet regex = /[a-z]ello/;\n\nconsole.log(regex.test('hello'));\n// returns true\n\nconsole.log(regex.test('cello'));\n// returns true\n\nconsole.log(regex.test('jello'));\n// returns true\n```\n\nIf at least one character exists in the range we test, it’ll return true:\n\n```\n/[a-z]/.test('a')  // true\n/[a-z]/.test('1')  // false\n/[a-z]/.test('A')  // false (as our range is in lower case)\n/[a-c]/.test('d')  // false\n/[a-c]/.test('cd') // true (as 'c' is in the range)\n```\n\nRanges can also be combined using `-`:\n\n```\n/[A-Z-0-9]/\n\n/[A-Z-0-9]/.test('a') // false\n/[A-Z-0-9]/.test('1') // true\n/[A-Z-0-9]/.test('A') // true\n```\n\n**Multiple range item matches**\n\nWe can check if a string contains one or only one character in a range. Start the regex with `^` and end with`$` :\n\n```\n/^[A-Z]$/.test('A')  // true\n/^[A-Z]$/.test('AB') // false\n/^[A-Z]$/.test('Ab') // false\n/^[A-Z-0-9]$/.test('1')  // true\n/^[A-Z-0-9]$/.test('A1') // false\n```\n\n### Meta-characters\n\n*Meta-characters are characters with a special meaning. Let’s take a look at some of these here:*\n\n* `\\d` : matches any digit, being`[0-9]`\n* `\\D`: matches any character that is not a digit, effectively`[^0-9]`\n* `\\w`: matches any alphanumeric character (plus underscore), equivalent to `[A-Za-z_0-9]`\n* `\\W`: matches any non-alphanumeric character, so anything except `[^A-Za-z_0-9]`\n* `\\s`: matches any whitespace character: spaces, tabs, newlines and Unicode spaces\n* `\\S`: matches any character that is not a whitespace\n* `\\0`: matches null\n* `\\n`: matches a newline character\n* `\\t`: matches a tab character\n* `\\uXXXX`: matches a [unicode](https://flaviocopes.com/unicode/) character with code XXXX (requires the `u` flag)\n* `.`: matches any character that is not a newline char (e.g. `\\n`) (unless you use the `s` flag, explained later on)\n* `[^]`: matches any character, including newline characters. It’s very useful on multi-line strings\n\n### Quantifiers\n\nQuantifiers are symbols that have unique meaning in regex.\n\nLet’s see them in action:\n\n* `+`Matches the preceding expression 1 or more times:\n\n```\nlet regex = /\\d+/;\n\nconsole.log(regex.test('1'));\n// true\n\nconsole.log(regex.test('1122'));\n// true\n```\n\n* `*`Matches the preceding expression 0 or more times:\n\n```\nlet regex = /\\d+/;\n\nconsole.log(regex.test('1'));\n// true\n\nconsole.log(regex.test('1122'));\n// true\n```\n\n* `?`Matches the preceding expression 0 or 1 time, that is preceding pattern is optional:\n\n```\nlet regex = /hii?d/;\n\nconsole.log(regex.test('hid'));\n// true\n\nconsole.log(regex.test('hiid'));\n// true\n\nconsole.log(regex.test('hiiid'));\n// false\n```\n\n* `^`Matches the beginning of the string, the regex that follows should be at the start of the test string:\n\n```\nlet regex = /^h/;\n\nconsole.log(regex.test('hi'));\n// true\n\nconsole.log(regex.test('bye'));\n// false\n```\n\n* `$` Matches the end of the string, the regex that precedes it should be at the end of the test string:\n\n```\nlet regex = /.com$/;\n\nconsole.log(regex.test('test@email.com'));\n// true\n\nconsole.log(regex.test('test@email'));\n// false\n```\n\n* `{N}` Matches *exactly* N occurrences of the preceding regex:\n\n```\nlet regex = /hi{2}d/;\n\nconsole.log(regex.test('hiid'));\n// true\n\nconsole.log(regex.test('hid'));\n// false\n```\n\n* `{N,}` Matches *at least* N occurrences of the preceding regular expression.\n\n```\nlet regex = /hi{2,}d/;\n\nconsole.log(regex.test('hiid'));\n// true\n\nconsole.log(regex.test('hiiid'));\n// true\n\nconsole.log(regex.test('hiiiid'));\n// true\n```\n\n* `{N,M}` Matches *at least* N occurrences and *at most* M occurrences of the preceding regex (when M > N).\n\n```\nlet regex = /hi{1,2}d/;\n\nconsole.log(regex.test('hid'));\n// true\n\nconsole.log(regex.test('hiid'));\n// true\n\nconsole.log(regex.test('hiiid'));\n// false\n```\n\n* `X|Y` Alternation matches *either* X or Y:\n\n```\nlet regex = /(red|yellow) bike/;\n\nconsole.log(regex.test('red bike'));\n// true\n\nconsole.log(regex.test('yellow bike'));\n// true\n\nconsole.log(regex.test('brown bike'));\n// false\n```\n\n*Note:* To use any special character as a part of the expression, for example if you want to match literal `+` or `.`, then you’ll need to escape them with a backslash `\\`. Like so:\n\n```\nlet regex = /a+b/;  \n// this doesn't work\n\nvar regex = /a\\+b/; \n// this works!\n\nconsole.log(regex.test('a+b')); \n// true\n```\n\n## Reviewing Regex\n\nWith these concepts fresh in our minds, let’s review what we’ve learned!\n\n### Match any 10 digit number:\n\n```\nlet regex = /^\\d{10}$/;\n\nconsole.log(regex.test('4658264822'));\n// true\n```\n\nSo `\\d` matches any digit character. `{10}` matches the previous expression, in this case `\\d` **exactly** 10 times. So if the test string contains less than or more than 10 digits, the result will be false.\n\n### Match a date with the following format:\n\n`DD-MM-YYYY`**or** `DD-MM-YY`\n\n```\nlet regex = /^(\\d{1,2}-){2}\\d{2}(\\d{2})?$/;\n\nconsole.log(regex.test('01-01-2000'));\n// true\n\nconsole.log(regex.test('01-01-00'));\n// true\n\nconsole.log(regex.test('01-01-200'));\n// false\n```\n\nHere we’ve wrapped the entire expression inside `^`and `$`, so that the match spans the entire string. `(` is the start of first sub-expression. `\\d{1,2}` matches at *least* 1 digit and at *most* 2 digits. `-` matches the literal hyphen character. `)` is the end of first sub-expression.\n\nThen `{2}` matches the first sub-expression exactly 2 times. `\\d{2}` matches exactly 2 digits. `(\\d{2})?` matches exactly 2 digits. However it’s optional, so either year contains 2 digits or 4 digits.\n\n## Conclusion\n\nAnd there we go! We’ve examined Regular Expressions from the very basics right through to more advanced implementations. Including both the literal and constructor methods, testing methods, flags and character syntax.\n\nRegular expressions can indeed be fairly complex! However, taking the time to learn the syntax will greatly help you to identify the regex patterns more easily. Any new confidence you gain will surely have you ready to conquer the next obstacle you encounter on your coding journey!",
  "title": "Understanding Regex",
  "description": "How to work with regular expressions (regex) in JavaScript.",
  "short": "How to work with regular expressions (regex) in JavaScript.",
  "category": "JavaScript",
  "thumbnail": "/images/uploads/javascript-regex.png"
}