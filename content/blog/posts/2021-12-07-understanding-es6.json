{
  "date": "Tuesday December 7th, 2021",
  "dateshort": "December 7th",
  "body": "ES6 (or ECMAScript 2015) is the 6th version of the ECMAScript programming language. ECMAScript is the standardization of JavaScript which was released in 2015, hence the name: ECMAScript 2015!\n\nA great advantage of ES6, is that it allows us to write code in a more modern & readable way. It has also introduced a number of new features such as: let/const, arrow functions, a new ‘this’ scope, classes, getters/setters, modules, template literals, default parameters, the spread operator, destructuring, the for..of loop and a whole lot more!\n\n## let and const\n\nES6 introduces two new keywords for defining variables: `let` and `const`. Whilst `var` can still be used, it’s now discouraged with the push to modern coding standards. Let’s compare some use cases for each..\n\n`var` is **function scoped**.\n\n`let` is **block scoped**.\n\nThe `let` variable works similarly to `var` with this key difference. Also, note that any variables declared with `let` will be **mutable** (their values can be changed).\n\nSo for example, if we declare variables in a for loop with `let`, inside an if or in a plain block, it cannot “escape” the block, while `var`s are hoisted up to the function definition.\n\n`const` is just like `let`, but **immutable** (sort of!).\n\nIt’s mainly used to store a value in a variable that will not be changed. The key difference between `let` and `const` is that once you’ve assigned a value to a variable using `const`, you can’t reassign it to a new value.\n\nHowever, just because a variable is declared with `const` doesn’t mean it’s immutable, all it means is the value can’t be re-assigned.\n\nTechnically, the reference itself is **immutable**, but the value held by the variable does not become immutable.\n\nIn JavaScript today, you’ll likely see little to no `var` declarations, the convention is now to use just `let` and `const`.\n\n## Arrow Functions\n\nArrow functions have changed how most JavaScript code looks (and works!). They are a much more concise syntax for writing functions, from:\n\n```\n// Old Syntax\nconst something = function something() {\n  //...\n}\n```\n\nTo the much more readable:\n\n```\n// New Syntax\nconst something = () => {\n  //...\n}\n```\n\nThere are two new parts to the syntax:\n\n* `const something = ()`\n* `=> {}`\n\nThe first part is our variable declaration and assignment of the function, i.e`()`. It just sets the variable as a function.\n\nThe second part, i.e. `=>,` is declaring the body of the function. The arrow is followed by the curly braces which contain the body.\n\nArrow functions can be even simpler if the function body is a one-liner:\n\n```\nconst something = () => doSomething()\n```\n\nAlso, if you have a single parameter, you could write:\n\n```\nconst something = param => doSomething(param)\n```\n\nFunctions with the older syntax will continue to work as before. However, as we move forward to a more modern & concise syntax, ES6 arrow functions are the superior choice!\n\n### A note regarding '`this’` scope\n\nWith arrow functions, the `this` scope is inherited **from the context**.\n\nRemember with regular functions, `this` always refers to the nearest function.\n\nThe problem we had is now removed, and you won’t find yourself writing `var that = this` anymore!\n\n## Classes\n\nClasses are the core of Object-Oriented Programming (OOP). With ES6, classes were introduced into JavaScript. Essentially they are syntactic sugar over the inner working, but they have changed the way we structure many programs. Classes can be used to create new objects with the help of constructors (note: each class can only have one constructor).\n\nLet’s see an example:\n\n```\nclass Person {\n  constructor(name) {\n    this.name = name\n  }\n\n  hello() {\n    return 'Hello, I'm ' + this.name + '.'\n  }\n}\n\nclass Musician extends Person {\n  hello() {\n    return super.hello() + ' I am a musician.'\n  }\n}\n\nlet prince = new Musician('Prince')\nPrince.hello()\n\n// output: \"Hello, I'm Prince. I am a musician.\"\n```\n\nClasses don’t have explicit class variable declarations, but you must initialize any variable within its constructor.\n\n## Getters and setters\n\nWithin a class we can choose to utilize ‘getters’ and ‘setters’. They’re a useful feature introduced in ES6, that are particularly handy when using classes:\n\nSee the below example, **without** getters and setters:\n\n```\nclass People {\nconstructor(name) {\n      this.name = name;\n    }\n    getName() {\n      return this.name;\n    }\n    setName(name) {\n      this.name = name;\n    }\n}\n\nlet person = new People(\"Taylor Phinney\");\nconsole.log(person.getName());\nperson.setName(\"Fred\");\nconsole.log(person.getName());\n\n// Output:\nTaylor Phinney\nFred\n```\n\nWe can see above that we have two functions in our `People` class, which get and set the name of the person.\n\nNow let’s see how to do this, using ES6 getters and setters:\n\n```\nclass People {\n\nconstructor(name) {\n      this.name = name;\n    }\n    get Name() {\n      return this.name;\n    }\n    set Name(name) {\n      this.name = name;\n    }\n}\n\nlet person = new People(\"Taylor Phinney\");\nconsole.log(person.Name);\nperson.Name = \"Fred\";\nconsole.log(person.Name);\n```\n\nNow you’ll see there are two functions inside class `People` with ‘get’ and ‘set’ properties. The ‘get’ property is used to get the value of the variable and ‘set’ property is used to set the value to the variable.\n\nAnd the `getName` function is called without parenthesis. Also `setName` is called without parenthesis. It’s just like assigning a value to the variable!\n\n## Modules\n\nModules are extremely useful for the organisation of code into logical files within our projects. Before ES6, there were a number of module solutions that we’re used throughout the community, such as RequireJS, CommonJS and AMD.\n\nWith ES6 we have these now standardized into a unified format.\n\nIn ES6 each module is defined in its own file. Functions and variables in one module are not at all visible in another module unless they’ve been exported.\n\n**Importing** is done via the `import ... from ...` construct:\n\n```\nimport * from 'mymodule'\nimport React from 'react'\nimport { React, Component } from 'react'\nimport React as MyLibrary from 'react'\n```\n\nWhen **exporting**, you can write modules and export anything to other modules using the `export` keyword:\n\n```\nexport var number = 10\nexport function bar() { /* ... */ }\n```\n\nTo consume the exported variables in a different module, you use `import`.\n\n## Template Literals\n\nTemplate literals allow us to work with strings in a better way than we have in the past. See the below example of creating a string:\n\n```\nconst myString = `My string`\n```\n\n*Note:* we use back-ticks ``` `` ``` rather than the single or double-quotes.\n\nTemplate literals provide a way to embed expressions into strings, effectively inserting the values, by using the `${variable}` syntax:\n\n```\nconst name = 'John'\nconst string = `Text ${name}` // Text John\n```\n\nPrior to ES6, we would’ve used the `+` operator to concatenate strings or also when using a variable inside a string. Template literals are much more readable!\n\nYou can, of course, perform more complex expressions as well:\n\n```\nconst string = `text ${1 + 2 + 3}`\nconst string2 = `text ${doSomething() ? 'x' : 'y' }`\n```\n\nAlso, we can span strings over multiple lines, like so:\n\n```\nconst string3 = `This\nstring \n\nis neat!`\n```\n\nIt’s far easier to write than the old multi-line syntax:\n\n```\nvar str = 'One\\n' +\n'Two\\n' +\n'Three'\n```\n\nBy using template literals, we can drastically improve our code readability.\n\n## Default parameters\n\nWith ES6, functions now support default parameters:\n\n```\nconst myFunction = function(index = 0, testing = true) { /* ... */ }\nmyFunction()\n```\n\nDefault parameters allow you to define a parameter in advance, which can be helpful in many scenarios. In JavaScript, our function parameters default to undefined. We now have the ability to set a different default value.\n\nBefore ES6, we used to define default parameters by testing the parameters’ value in the default function body and assigning a value **if** it was undefined.\n\n## The spread operator\n\nThe Spread operator (`...`) is an operator provided by ES6 that allows us to easily obtain a list of parameters from an array.\n\nLet’s start with an array example:\n\n```\nconst a = [1, 2, 3]\n```\n\nYou can create a new array, like so:\n\n```\nconst b = [...a, 4, 5, 6]\n```\n\nYou can also create a copy of an array:\n\n```\nconst c = [...a]\n```\n\nThis also works for cloning objects:\n\n```\nconst newObj = { ...oldObj }\n```\n\nWhen using strings, the spread operator can create an array with each character in the string:\n\n```\nconst hello = 'hello'\nconst imArrayed = [...hello] // ['h', 'e', 'l', 'l', 'o']\n```\n\nWe can also now use an array as a function argument in a very simple way:\n\n```\nconst f = (arg1, arg2) => {}\nconst a = [1, 2]\nf(...a)\n```\n\n## Destructuring assignments\n\nDestructing in JavaScript is essentially the breaking down of a complex structure (such as objects or arrays) into simpler parts. With the destructing assignment, we ‘unpack’ array objects into a number of variables.\n\nInstead of declaring variables separately for each of the properties of an object, we just put our values within curly brackets to access any property of the object.\n\nFor example, let’s extract some values from an object and put them into named variables:\n\n```\nconst person = {\n  firstName: 'Bill',\n  lastName: 'Billson',\n  famous: false,\n  age: 45,\n}\n\nconst {firstName: name, age} = person\n```\n\n`name` and `age` contain our desired values.\n\nAnd the syntax works on arrays:\n\n```\nconst a = [1,2,3,4,5]\nconst [first, second] = a\n```\n\nThis statement creates three new variables by getting the items with index **0, 1, 4** from the array `a`:\n\n```\nconst [first, second, , , fifth] = a\n```\n\n## For-of loop\n\nPrior to ES6 it was common to use `forEach()` loops. They served the purpose quite well but offered no way to break, like `for` loops always have.\n\nES6 has given us the `for-of`loop, which combines the conciseness of `forEach` with the ability to break:\n\n```\n// Iterate over a value\nfor (const x of ['a', 'b', 'c']) {\n  console.log(x);\n}\n\n// Get the index, using `entries()`\nfor (const [i, x] of ['a', 'b', 'c'].entries()) {\n  console.log(i, x);\n}\n```\n\n## Conclusion\n\nAnd there we go! We’ve looked at a number of new ES6 features such as: let/const, arrow functions & it’s ‘this’ scope, classes, getters/setters, modules, template literals, default parameters, the spread operator, destructuring and the for..of loop.\n\nSo we can now implement this modern syntax, and bring our JavaScript to the next level!",
  "title": "Understanding ES6",
  "description": "Learn what changed in JavaScript with ES6.",
  "short": "Learn what changed in JavaScript with ES6.",
  "category": "JavaScript",
  "thumbnail": "/images/uploads/javascript-es6.png"
}