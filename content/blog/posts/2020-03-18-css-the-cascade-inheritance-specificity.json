{
  "date": "Wednesday March 18th, 2020",
  "dateshort": "March 18th",
  "title": "The Cascade, Inheritance & Specificity",
  "short": "A review of the fundamental concepts of CSS.",
  "category": "CSS",
  "description": "A review of the fundamental concepts of CSS.",
  "body": "In this article, we’re going to review some of the most fundamental concepts of CSS. The cascade, inheritance and specificity.\n\n# What is the Cascade?\n\nIt’s the ‘C’ in CSS (**C**ascading **S**tyle **S**heets), so conceptually it lies at the very core of CSS. The cascade is the **algorithm which determines the properties applied to page elements.**\n\nThis determination is made based on inheritance, specificity, importance, & rule order.\n\nThe cascade also ensures we have no conflicts in our stylesheets. If we have multiple CSS rules, for the same property & on the same element - it determines which rule is applied.\n\nSo let's keep the cascade in mind, while we take a look at the rules it uses to make these decisions!\n\n# Inheritance\n\nInheritance works on a property by property basis. When you set properties on a selector in CSS, they're either inherited by all the children of that selector or they're not. It depends on the property!\n\nThe reason being that some properties make sense to be inheritable, whilst others do not.\n\nWhen working with fonts, you don’t need to apply styles such as `font-family` or `font-size` to every single element on your page. You can simply set these styles on the body tag & every child will inherit it.\n\nHowever a property such as `background-color`, makes little sense to be inherited. So the children of the element that this is applied to, will **not** inherit this property. \n\nYou can check if a particular property is inheritable [here](https://developer.mozilla.org/en-US/docs/CSS/CSS_Reference).\n\nInheritance helps us write our CSS much more concisely. As we don't have to explicitly set every property, in every child element!\n\n## Enforcing Property Inheritance\n\nIf a property is not inheritable by default, you can force inheritance to its children.\n\nIn the child selector, you set the property value to `inherit`.\n\n```CSS\nbody {\n   background-color: red;\n}\n\np {\n   background-color: inherit;\n}\n```\n\n## Avoiding Property Inheritance\n\nThe reverse is also possible. By using the `revert` keyword, the property will **not** inherit from its parent. In this case, the value is reverted to the original default given by the browser.\n\n## Initial & Unset\n\nIt’s worth mentioning that we can also use the initial & unset keywords.\n\n* `initial`: sets a CSS property to its default value (the browser default).\n* `unset`: resets a property to its inherited value if it inherits from its parent, and to its initial value if not.\n\n# Specificity\n\nWhen an element is targeted by multiple CSS rules — specificity comes into play!\n\nLet’s take a look at the following element:\n\n```HTML\n<p class=\"surname\">\n  Smith\n</p>\n```\n\nWe could have one rule selecting our class:\n\n```CSS\n.surname {\n  color: red;\n}\n```\n\nAnd another rule targeting `p`, which sets the color to a different value:\n\n```CSS\np {\n  color: green;\n}\n```\n\nAnd we could even have another rule targeting `p.surname`!\n\nSo which rule will take precedence over the others, and why?\n\nThis is where the rules of specificity come into consideration. And **the more specific rule will always win**. If we have two or more rules with the **same specificity, the one that appears last wins.**\n\nSpecificity is determined by a calculation. The more specific a style rule is, the higher point value it accrues, and the likelier it is to be present on the element’s style.\n\n## How we calculate specificity\n\nUnderstanding how specificity works, will greatly reduce any frustrations we may have with CSS.\n\nIf we’ve applied a style to an element that isn’t taking effect, the culprit is likely a selector that isn’t specific enough!\n\nTo perform the calculation, think of 4 slots with each of them starting at 0.\n\n`0 0 0 0`\n\nThe slot on the left is the most important, and the rightmost is the least important.\n\nTherefore `1 0 0 0` is higher than `0 1 0 0`.\n\n### Slot 1\n\nThe first slot, the rightmost one (```0 0 0 ``0```), is the least important.\n\nThis value changes when we have a *type selector*. A type is a *tag name*. If you have more than one type selector in the rule, increment the value stored in this slot.\n\nFor example:\n\n```CSS\np {} \t\t /* 0 0 0 1 */\nspan {} \t /* 0 0 0 1 */\np span {} \t /* 0 0 0 2 */\np > span {}      /* 0 0 0 2 */\ndiv p > span {}  /* 0 0 0 3 */\n```\n\n### Slot 2\n\nThe number in the second slot is determined by the following:\n\n* Class selectors\n* Pseudo-class selectors\n* Attribute selectors\n\nEvery time a rule contains one of the above selectors, we increment the value of the second column from the right.\n\nFor example:\n\n```CSS\n.city {}\t    /* 0 0 1 0 */\n.users .city {}\t    /* 0 0 2 0 */\n[type=\"button\"] {}  /* 0 0 1 0 */\n:hover {}\t    /* 0 0 1 0 */\n```\n\nAnd naturally, slot 2 selectors can be combined with slot 1 selectors:\n\n```CSS\np .city {}\t         /* 0 0 1 1 */\ninput[type=\"button\"] {}  /* 0 0 1 1 */\n.images img:hover {}     /* 0 0 2 1 */\n```\n\n### Slot 3\n\nSlot 3 is reserved for `id`’s.\n\nEvery HTML element can have an `id` attribute assigned. And we can use `id`’s to target elements specifically.\n\nFor example:\n\n```CSS\n#city {}\t/* 0 1 0 0 */\n.user #city {}\t/* 0 1 1 0 */\n#city span {}\t/* 0 1 0 1 */\n```\n\n### Slot 4\n\nSlot 4 is altered by *inline styles*. Any inline style will have precedence over **any** **rule** defined in an external CSS file, or inside the `style` tag in the page header.\n\nFor example:\n\n```HTML\n<p style=\"color: yellow\">Text</p>  /* 1 0 0 0 */\n```\n\nEven if any other rule in the CSS defines the color, the inline style rule will be applied.\n\nThere is just one exception— if `!important` is used.\n\n## Importance\n\nOur specificity is completely void if a rule ends with `!important`:\n\n```CSS\np {\n  font-size: 18px !important;\n}\n```\n\nBy adding `!important` to a CSS rule, it’ll be made more important than any other rule, according to the specificity rules.\n\nImportance seems like a magic way to ensure a style is applied, however, it can become a nightmare to work with down the line. As the only way you can override `!important` is with another `!important`. Thus you can really make a mess of your CSS when you go down that path.\n\nBest practice is to not use importance. Instead you should look for a more specific selector.\n\n## Summing up..\n\nA great rule of thumb is to only use the amount of specificity you need, but no more. So you can craft selectors that overwrite rules set by preceding rules, without too much difficulty!\n\nI hope you enjoyed this article, in the next one we'll be looking at CSS Attribute selectors. See you then!"
}