{
  "date": "Friday July 23rd, 2021",
  "dateshort": "July 23rd",
  "body": "Functions can be thought of as one of the core building blocks of our JavaScript programs. A function is simply a set of statements designed to perform a particular task — which is executed whenever it is invoked (or “called”).\n\nIn this article we’re going to take a look at defining functions, function expressions, calling functions, scope, nesting, closures, the arguments object, function parameters & arrow functions!\n\n## Defining functions\n\nA function definition (otherwise known as a function declaration, or function statement) will always begin with the `function `keyword. What follows is the *name* of our function, any *parameters* enclosed in parenthesis, and then our JavaScript *statements* (enclosed in `{ }`) which are executed when our function is called.\n\nLet’s see an example:\n\n```\nfunction multiply(a, b) {\n  return a * b;\n}\n```\n\nOur function `multiply` takes two parameters (`a` and `b`). Included in-between the curly braces is a statement that returns the result of the first parameter `a` multiplied by the second parameter `b`.\n\n## Function expressions\n\nThere is another way to define a function, known as the function expression. These types of functions can actually be *anonymous.* They don’t need to be given a name.\n\nFor example, our previous `multiply` function could’ve also been defined like so:\n\n```\nlet multiply = function(a, b) { return a * b; };\nlet x = multiply(2,2); // x returns 4\n```\n\nA typical use case for function expressions might be when passing a function as an argument to another function.\n\nWe *can* also define a function based on a condition. For example, the following function defines `addItem` only if `num` equals 1:\n\n```\nlet addItem;\nif (num === 1) {\n  addItem = function(shoppingList) {\n    shoppingList.item = 'Apples';\n  }\n}\n```\n\n## Calling functions\n\nWhen we define a function all we’ve done is given it a name & specified what to do when the function executes. So to actually run the function, we’ll need to call it within our program!\n\nTo call our earlier function `multiply`, we could invoke it as follows:\n\n```\nmultiply(2,2);\n```\n\nHere we’re calling our function which is set to receive two arguments with the arguments of `2` and `2`. The function executes and runs its statements which returns the result of `4`(2 multiplied by 2).\n\nFunctions need to be in scope when they are called, but the function declaration can be hoisted (appear below the call in the code), like so:\n\n```\nconsole.log(multiply(2,2));\n/* ... */\nfunction multiply(a,b) { return a * b; }\n```\n\nThe scope of a function is the function in which it is declared, or the entire program if it is declared at the global level.\n\n*Note:* *This only works with function declarations. Not function expressions!*\n\n## Function scope\n\nWhen variables are defined inside a function they cannot be accessed anywhere outside of that function. As that would be outside the scope. However, a function is able to access all variables and functions defined inside the scope in which it is defined. So a function defined in the global scope can access all variables defined in the global scope. A function defined inside another function can also access all variables defined in its parent function and any other variable to which the parent function has access.\n\nLet’s see an example...\n\n```\n// These variables are defined globally (global scope)\nlet a = 10,\n    b = 3,\n    name = 'Bruce';\n// This function is defined globally \nfunction multiply() {\n  return a * b;\n}\nmultiply(); // returns 30\n// Working with a nested function\nfunction multiplyAssign() {\n  let a = 20,\n      b = 6;\n  \n  function add() {\n    return name + ‘ received’ + (a * b);\n  }\n  \n  return add();\n}\nmultiplyAssign(); // returns \"Bruce received 120\"\n```\n\n## Nesting functions and closures\n\nSo you can nest a function within a function! The nested (inner) function is private to its containing (outer) function. It also forms a closure. A closure is an expression (usually a function) that can have free variables together with an environment that binds those variables (it “closes” the expression).\n\nAnd as a nested function is a closure, it’s able to “inherit” the arguments and variables of its containing function.\n\nAs follows:\n\n```\nfunction addSquares(a, b) {\n  function square(x) {\n    return x * x;\n  }\n  return square(a) + square(b);\n}\na = addSquares(2, 3); // returns 13\nb = addSquares(3, 4); // returns 25\nc = addSquares(4, 5); // returns 41\n```\n\nSince the inner function forms a closure, you can call the outer function and specify arguments for both the outer **and** inner function!\n\n## Closures\n\nAs we now know, we can nest our functions and JavaScript will give the inner function full access to all the variables and functions defined inside the outer function (as well as all variables & functions that it has access to).\n\nHowever, the outer function does not have access to the variables and functions defined inside the inner function! A closure is created when the inner function is somehow made available to any scope outside the outer function.\n\nLet’s see an example:\n\n```\n// The outer function defines a \"name\" variable\nlet user = function(name) {   \n  let getName = function() {\n    return name;             \n    // The inner function can access the \"name\" variable of the  outer function\n  }\n// Return the inner function, and expose it to outer scopes\nreturn getName;            \n}\nmakeAdmin = user('Steve Stevesson');\n   \nmakeAdmin(); // returns \"Steve Stevesson\"\n```\n\n## The arguments object\n\nThe arguments of any function are maintained in an *array-like* object. Within a function, you can address the arguments pas*s*ed to it as follows:\n\n```\narguments[i]\n```\n\nHere `i` is the first number of the argument, starting at zero. So, the first argument passed to a function would be `arguments[0]`. The total number of arguments would be `arguments.length`.\n\nUsing the `arguments` object, you can call a function with more arguments than it is formally declared to accept. This is often useful if you don't know in advance how many arguments will be passed to the function. You can use `arguments.length` to determine the number of arguments actually passed to the function, and then access each argument using the `arguments` object.\n\nFor example, consider a function that concatenates several strings. The only formal argument for the function is a string that specifies the characters that separate the items to concatenate. The function is defined as follows:\n\n```\nfunction myConcat(separator) {\n   let result = ''; // initialize list\n   let i;\n   // loop through arguments\n   for (i = 1; i < arguments.length; i++) {\n      result += arguments[i] + separator;\n   }\n   return result;\n}\n```\n\nYou can pass any number of arguments into this function, and it’ll concatenate each argument into a string “list”:\n\n```\nmyConcat(', ', 'fred', 'wilma', 'barney', 'betty');\n// returns \"fred, wilma, barney, betty, \"\nmyConcat('; ', 'marge', 'homer', 'lisa', 'bart', 'maggie');\n// returns \"marge; homer; lisa; bart; maggie; \"\nmyConcat('. ', 'jerry', 'kramer', 'elaine', 'george', 'newman');\n// returns \"jerry. kramer. elaine. george. newman. \"\n```\n\n*Note:* The `arguments` variable is \"array-like\", but not an array. It has a numbered index and a `length` property. However, it does not possess all of the array-manipulation methods.\n\n## Function parameters\n\nThere are two kinds of function parameters: *default* parameters and *rest* parameters. Let’s now take a look at each...\n\n### Default parameters\n\nIn JavaScript, parameters of functions will default to `undefined`. However, in some situations, it might be useful to set a different default value. This is where default parameters are useful.\n\nIt’s actually quite simple to implement:\n\n```\nfunction multiply(a, b = 1) {\n  return a * b;\n}\n\nmultiply(10); // 10\n```\n\nYou can simply put `1` as the default value for `b` in the function head.\n\n### Rest parameters\n\nThe rest parameter syntax allows us to represent an indefinite number of arguments as an array.\n\nIn this example, we use the rest parameters to collect arguments from the second one to the end. We then multiply them by the first one. This example uses an arrow function, which we’ll look at next!\n\n```\nfunction multiply(multiplier, ...theArgs) {\n  return theArgs.map(x => multiplier * x);\n}\n\nlet arr = multiply(2, 1, 2, 3);\nconsole.log(arr); // [2, 4, 6]\n```\n\n## Arrow functions\n\nAn arrow function has a *much* shorter syntax compared to function expressions. For example, here is a regular function:\n\n```\nfunction funcName(params) {\n  return params + 10;\n}\n\nfuncName(2); // 12\n```\n\nAnd here is the same function, expressed as an *arrow function*:\n\n```\nlet funcName = (params) => params + 10\n\nfuncName(2); // 12\n```\n\nThe same function in just one line of code! Pretty neat!\n\nIf we have no parameters, we express our arrow function like this:\n\n```\n() => { statements }\n```\n\nAnd when we have just one parameter, the opening parenthesis are optional:\n\n```\nparameters => { statements }\n```\n\nFinally, if you’re returning an expression, you can remove the brackets:\n\n```\nparameters => expression\n\n// is the same as:\n\nfunction (parameters){\n  return expression;\n}\n```\n\n*Note:* *Unlike a regular function, an arrow function does not bind `this`. Instead, `this` is bound to keep its meaning from its original context. We’ll be taking a closer look at the “this” keyword in an upcoming article!*\n\n## Predefined functions\n\nIt’s well worth noting that JavaScript has numerous built-in functions! And they’ll likely save you a lot of time, especially for common tasks. See:\\\n<https://www.tutorialspoint.com/javascript/javascript_builtin_functions.htm>\n\n## Wrapping up\n\nAnd that’s all for today! We’ve learned about defining functions, function expressions, *calling* functions, scope, nesting, closures, the arguments object, function parameters & arrow functions!\n\n### Related Posts:\n\n* [Understanding Variables, Scope and Hoisting](https://www.easeout.co/blog/2021-01-25-understanding-variables-scope-and-hoisting/)\n* [Working with Strings in JavaScript](easeout.co/blog/2020-11-23-working-with-strings-in-javascript/)\n* [JavaScript Data Type Conversion](https://www.easeout.co/blog/2020-11-05-javascript-data-type-conversion/)",
  "title": "Mastering Functions",
  "description": "How to build functions in JavaScript.",
  "short": "How to build functions in JavaScript.",
  "category": "JavaScript",
  "thumbnail": "/images/uploads/javascript-functions-min.png"
}