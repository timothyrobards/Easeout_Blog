{
  "date": "Tuesday October 6th, 2020",
  "dateshort": "October 6th",
  "title": "React JSX and Rendering",
  "short": "Learn about JSX and rendering in React.",
  "category": "React",
  "description": "Learn about JSX and rendering in React.",
  "body": "If you’re new to React, you’ll likely have heard about JSX, or *JavaScript XML —* it’s an XML-like code for elements and components. In this article, we’re going to take a look at what JSX is & why we should use it in our React applications. We’ll also take a look at what elements are, and how we can render them to the DOM.\n\n## What is JSX?\n\nAs mentioned, JSX is an XML-like code which we can use when coding with React. It was developed by the team at Facebook & is mean’t to provide a more concise syntax, helping to simplify the developer experience. Let’s take a look at our first example:\n\n```react\nconst greeting = <h1>Hello, World!</h1>;\n```\n\nSimple, right?\n\nWhat we have here is neither a string nor HTML. It’s JSX! We can use it to harness the full power of JavaScript when building our UI elements. And while it’s not mandatory, it’s certainly an extremely useful tool — it does a great job of making it clear when we’re working with UI inside of our JavaScript code.\n\n## Using JSX\n\nLet’s extend our above example to include an embedded expression.\n\n```react\nconst user = 'Bob Burger';\nconst greeting = <h1>Hello, {user}</h1>;\n\nReactDOM.render(\n  greeting,\n  document.getElementById('root')\n);\n```\n\nWe use curly braces `{}` to embed the variable into our JSX expression. And within those curly braces we could embed any valid JavaScript expression. Such as `user.firstName` or `printName(user)` for example.\n\n*Note:* We’ll look at rendering in detail later in the article, don’t be to concerned about the above render method just yet!\n\nLet’s embed the result of a called JavaScript function:\n\n```react\nfunction printName(user) {\n  return user.firstName + ' ' + user.lastName;\n}\n\nconst user = {\n  firstName: 'Bob',\n  lastName: 'Burger'\n};\n\nconst greeting = (\n  <h1>\n    Hello, {printName(user)}!\n  </h1>\n);\n\nReactDOM.render(\n  greeting,\n  document.getElementById('root')\n);\n```\n\n## JSX Under the hood\n\nSo whats actually going on with JSX, when we render components?\n\n```react\nfunction Greeting() {\n  return <h1>Hello, World!</h1>\n}\n```\n\nEach element being rendered by the `Greeting` component are transpiled down into `React.createElement` calls. The above example transpiles to:\n\n```react\nfunction Greeting() {\n  return React.createElement(\"h1\", {}, \"Hello, World!\")\n}\n```\n\n### React.createElement()\n\nLet’s see another example:\n\n```react\nconst greeting = (\n  <h1 className=\"speak\">\n    Hello, world!\n  </h1>\n);\n```\n\nWhen compiled, this code looks as follows:\n\n```react\nconst greeting = React.createElement(\n  'h1',\n  {className: 'speak'},\n  'Hello, world!'\n);\n```\n\nBoth of these code blocks are identical. And essentially an object is created like so:\n\n```react\nconst greeting= {\n  type: 'h1',\n  props: {\n    className: 'speak',\n    children: 'Hello, world!'\n  }\n};\n```\n\nThis object is known as a React element, and it functions a lot like a description of what you see on the screen. React uses these objects to build the DOM and keep it up to date.\n\nEssentially, JSX is really just making the `React.createElement(component, props, …children)` function much more pleasing on the eye. Another example:\n\n```react\n<Navbar backgroundColor = \"purple\" opacity = {0.8}>\n  Menu bar\n</Navbar>\n```\n\nWill transpile to:\n\n```react\nReact.createElement(Navbar, {\n  backgroundColor: \"purple\",\n  opacity: 0.8\n}, \"Menu bar\");\n```\n\nLet’s now move on the see a few more concepts…\n\n## Props in JSX\n\nWe’ll take a deep dive into **props** in my next article! For now its good to remember that when building components — they’ll often render children, which require data to render correctly. The parameters we pass in are what we call props. In JSX, there are a few ways we can do this, such as:\n\n```react\n// Defaults to \"true\" if no value is passed\n<MyComponent connected />\n// String literals passed as props\n<MyComponent user= \"Bob Burger\" />\n// Expressions (below example will evaluate to 10)\n<MyComponent total = {1 + 2 + 3 + 4} />\n// Spread attributes: passes the whole props object\n<MyComponent selected = {...this.state} />\n```\n\nNote: `if` statements and `for` loops are not expressions in *JavaScript*, so they cannot be used in JSX directly! Instead, you could code it like so:\n\n```react\nfunction NumberType(props) {\n  let answer;\n  if (props.number % 2 == 0) {\n    answer = <strong>even</strong>;\n  } else {\n    answer = <i>odd</i>;\n  }\n  return <div>{props.number} is an {answer} number</div>;\n}\n```\n\nWe can see our props passed into the conditional, evaluated and then returned — all via JSX.\n\n## Children in JSX\n\nAs your apps become larger, you’ll find some components will need to render children. And then those child components will also need to render further children, and so on! With JSX, we can manage these tree-like structures of elements quite well. The rule of thumb is — whatever elements a component returns become its children.\n\nLets take a quick look at the ways to render child elements with JSX:\n\n### String Literals\n\n```react\n<MyComponent>I'm a child!</MyComponent>\n```\n\nIn this very basic example, the string `I’m a child` is a child of `MyComponent`. And its accessible via `props.children` of `MyComponent`.\n\n### JSX Elements as Children\n\nSay we want to return an HTML child `<header>`, which has two of its own children: `<Nav />` and `<SearchBox />`. We could do this like so:\n\n```react\nfunction Header(props) {\n  return (\n    <header>\n      <Nav />\n      <SearchBox />\n    </header>\n  )\n}\n```\n\n### Expressions\n\nWe can also pass expressions as children, to render to our UI. This would be very useful with a to-do list app, for example:\n\n```react\nfunction TodoItem(props) {\n  return <li>{props.content}</li>;\n}\n\nfunction TodoList() {\n  const todos = ['paint house', 'buy more chips', 'conquer world'];\n  return (\n    <ul>\n      {todos.map((content) => <TodoItem key={content} content={content} />)}\n    </ul>\n  );\n}\n```\n\n### Functions\n\nFunctions can be useful when handling repetition, such as rendering repeated UI elements. We can create the structures that React will automatically render for us.\n\nLet’s look at an example where we use a `.map()` function to create new pages on a website:\n\n```react\n// Array of current pages\nconst pages = [\n  {\n    id: 1,\n    text: \"Home\",\n    link: \"/\"\n  },\n  {\n    id: 2,\n    text: \"About\",\n    link: \"/about\"\n  },\n  {\n    id: 3,\n    text: \"Contact\",\n    link: \"/contact\"\n  }\n];\n// Renders a <ul> which generates the <li> children\nfunction Nav() {\n  return (\n    <ul>\n      {pages.map(page => {\n        return (\n          <li key={page.id}>\n            <a href={page.link}>{page.text}</a>\n          </li>\n        );\n      })}\n    </ul>\n  );\n}\n```\n\nTo add a new page to our website, we just need to add a new object to the `pages` array & let React handle the rest!\n\n## Rendering Elements\n\nAs I’m sure you’ve seen throughout this article, when working with JSX we’re working with elements to render into our page. An *element* describes what you see on the screen:\n\n```react\nconst element = <h1>Hello!</h1>;\n```\n\nMultiple elements such as this when combined, will form components. We’ll be taking a detailed look at components in my next article!\n\n### Rendering our elements to the DOM\n\nTypically, we’ll have a `<div>` like so, in our HTML:\n\n```react\n<div id=\"root\"></div> \n```\n\nThis is known as our DOM node. Everything inside of it is handled by React DOM.\n\nAnd to render a React element into our root node, we pass both to `ReactDOM.render(),` like so:\n\n```react\nconst element = <h1>Hello!</h1>;\nReactDOM.render(element, document.getElementById('root'));\n```\n\n`Hello!` will render to our page.\n\n### Updating rendered elements\n\nNote that React elements are immutable! Once an element is created, you can’t change its children or its attributes. If if wish to update the UI, you’ll need to create a new element and pass it to `ReactDOM.render()`.\n\n## Wrapping up\n\nAnd there we go! We’ve covered the basics of JSX and rendering. And I hope you’re beginning to see how useful these concepts are to us as developers, building React apps.\n\nBy harnessing the power of JSX to pass around elements in JavaScript, we’re building very workable code. The structure of JSX plays incredibly well with React, and despite the fact that JSX isn’t mandatory — it makes for a fantastic development experience.\n\n## Related Posts:\n\n* [React Installation & Setup](https://www.easeout.co/blog/2020-09-27-react-installation-setup)\n* [React Components & Props](https://www.easeout.co/blog/2021-02-15-react-components-props)",
  "thumbnail": "/images/uploads/react-jsx-rendering.png"
}