{
  "date": "Saturday March 19th, 2022",
  "dateshort": "March 19th",
  "body": "While working with JavaScript, you’ll inevitably come across the `this` keyword. As a concept, it can be quite tricky to grasp! Normally `this` refers to the object that **owns** the method. However, its meaning is entirely different — depending on how the function is called.\n\nIn this article, we’ll be looking at `this` in detail.\n\n## A little background\n\nObjects are the basic building blocks of JavaScript! *And the `this` keyword will **always** refer to an object.* You can check its current value at every line of code execution. *The value of `this` is determined based on the code’s **execution context**.*\n\n### Execution Context\n\nJavaScript code is read and executed line by line. The environment (or scope), of the line currently being executed, is known as **Execution Context**.\n\nBehind the scenes, JavaScript runtime is maintaining a stack of these execution contexts and the context present at the top of this stack — is the one currently being executed.\n\nThe object that `this` refers to changes every time the execution context is changed.\n\nThis is why `this` can be difficult to understand! Let’s look at `this` in a number of different contexts — so we can learn how it works!\n\n## “this” in Global Scope\n\nIf there is no current object, `this` refers to the global object. Within our browser that happens to be the `window` object.* *It’s the top-level object which represents the document.\n\nLet’s test to confirm:\n\n```\nfunction testThis() { \n   console.log(this === window); \n} \n\ntestThis(); \n// returns true\n\nconsole.log(this === window) \n// returns true\n```\n\n## “this” when calling Function\n\nThe value of `this` remains as the global object if you’re calling a function:\n\n```\nwindow.check = \"Hi! I'm the window object\";\n\nfunction thisFunction() {\n\talert(this.check); // Hi! I'm the window object\n\talert(window === this); // true\n}\n\nthisFunction();\n```\n\n## “this” in Methods\n\nWhen we call a function as a method of an object, `this` refers to the object, which is then known as the receiver of the function call.\n\nIn the following example, the method `quote` is inside an object called `author`. The `quotes`‘ `this` value refers to `author` itself. So the `author` object will receive the `quote` method call:\n\n```\nconst author = {\n  name: \"Oscar Wilde\",\n  quote() {\n    console.log(`Be yourself. Everyone else is already taken. - ${this.name}`);\n  }\n};\nauthor.quote();\n```\n\n## “this” with call() and apply()\n\nA function’s `this` value is set implicitly, however, we can also call a function with an explicit `this` argument with `call()` and `apply()`.\n\nEssentially, `call()` and `apply()` run JavaScript functions as if they were methods of another object.\n\nLet’s see an example:\n\n```\nfunction testThis(type) {\n   this.test = \"I'm the \"+type+\"!\";\n}\n\nlet firstObject = {};\ntestThis.call(firstObject, \"firstObject\");\n\nconsole.log(firstObject.test); \n// I'm the firstObject\n\nlet secondObject = {};\ntestThis.apply(secondObject, [\"secondObject\"]);\n\nconsole.log(secondObject.test); \n// I'm the secondObject\n```\n\nThe only difference is that `call()` expects a discrete number of parameters while `apply()` can be passed an array of parameters.\n\nNote: If you’re using `call` or `apply` outside of **strict mode**, then passing `null` or `undefined` using `call` or `apply` will be ignored by the JavaScript engine. This is one of the reasons why it is usually suggested to always write code in strict mode!\n\n## “this” with bind()\n\nThe `bind()` method allows us to **permanently** tie a `this` argument to a value. So in the below example, `bind` will create a new `quote` function and set its `this` value to `author`.\n\n```\nconst author = {\n  name: \"Oscar Wilde\",\n  quote() {\n    console.log(`Be yourself. Everyone else is already taken. - ${this.name}`);\n  }\n};\nsetTimeOut(author.quote.bind(author), 1000);\n```\n\nBy doing so, our `this` cannot be changed with the `call` or `apply` methods.\n\n## “this” inside an Arrow Function\n\nUsing `this` with an arrow function is different from any other kind of JavaScript function. *An arrow function uses the `this` value from its enclosing execution context since it does have one of its own.*\n\nAn arrow function permanently captures the `this` value, preventing `apply` or `call` from being able to change it later on.\n\nFor example:\n\n```\nconst author = this;\n\nconst oscarWilde = () => {\n  console.log(this === oscarWilde);\n};\n\noscarWilde();\n// false\n```\n\nHere, we are storing the value of a `this` in a variable and then comparing the value with a `this` value that is inside an arrow function.\n\nAn arrow function’s `this` value **cannot** be set explicitly! Also, the arrow function will ignore any attempt to pass a value to `this` using methods like `call`, `apply`, and `bind`. An arrow function will refer to the `this` value that was set when the arrow function was created.\n\n*Note:* An arrow function can also not be used as a constructor. So we cannot assign properties to `this` inside an arrow function.\n\n## In Summary…\n\nSo now, you can figure out the value of `this` with these simple rules:\n\n* By default, `this` refers to global object — within the browser, this is the `window` object.\n* When a method is called as a property of object, `this` refers to the parent object.\n* When a function is called with a `new` operator, `this` refers to the newly created instance.\n* When a function is called using `call()` and `apply()`, then `this` refers to the value passed as the first argument of the method.\n\n## Conclusion\n\nAnd there we go! We’ve looked at how `this` works in a number of different contexts, such as global scope, functions, methods, `call()`, `apply()`, `bind()`, and arrow functions!",
  "title": "What is 'this'?",
  "description": "Learn what 'this' is in JavaScript.",
  "short": "Learn what 'this' is in JavaScript.",
  "category": "JavaScript",
  "thumbnail": "/images/uploads/javascript-what-this.png"
}