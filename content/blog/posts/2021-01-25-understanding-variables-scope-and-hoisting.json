{
  "date": "Monday January 25th, 2021",
  "dateshort": "January 25th",
  "body": "JavaScript variables are containers for storing data values. Conceptually, they are one of the most fundamental concepts to learn! You’ve likely heard of the three ways in which variables can be declared: `var`, `let` & `const`. \n\nIn this article, we’ll be taking a look at how we declare our variables & how we name them. We’ll take a look at how variables behave in our code, with hoisting and scope (local & global).\n\n## What are Variables?\n\nVariables are named containers for storing data values. Any piece of information that we wish to reference multiple times can be stored in a variable for later use. In JavaScript, the value contained inside of a variable can be of any [data type](https://www.easeout.co/blog/2020-10-27-understanding-javascript-data-types), including a number, string, or object.\n\nBefore the release of ES6, there was only one way to declare a variable — using the `var` keyword. You’ll still see `var` used quite often when working with older code. We’ll be looking at the newer conventions later in the article, but for now, let's look at an example using `var`:\n\n```javascript\n// Assign a string of “John Doe” to the “name” identifier\n\nvar name = “John Doe”;\n```\n\nHere we’ve declared our *variable* using `var`, our *identifier* is `name`, we’ve then *assigned* the variable using `=`, to the *value* of “John Doe”.\n\nNow we can use `name` in our code. JavaScript will remember that name represents the string value, John Doe.\n\n```javascript\n// Check if the variable is equal to a value\n\nif (name === “John Doe”) {\n  console.log(true);\n}\n\n// output: true\n```\n\nAs mentioned previously, variables can be used to represent any JavaScript data type. In this example, we’ll declare variables with string, number, object, Boolean, and null values.\n\n```javascript\n// Assignment of various variables\n\nvar name = “John”;\nvar total = 100;\nvar city = [ “Sydney”, “Tokyo”, “Montreal” ];\nvar things = { Food: “Pizza”, Drink: “Wine” };\nvar success = true;\nvar nothing = null;\n```\n\nWe can use console.log to see the value contained in a specific variable.\n\n```javascript\n// Send total variable to the console\n\nconsole.log(total);\n\n// output: 100\n```\n\nVariables store data in memory which can later be accessed and modified. Variables can also be reassigned and given a new value. The following example demonstrates how a password might be stored to a variable and then updated.\n\n```javascript\n// Assign value to password variable\nvar password = “qwerty1”;\n\n// Reassign variable value with a new value\npassword = “qwerty2”;\n\nconsole.log(password);\n// output: qwerty2\n```\n\nOf course, a password would likely be securely stored in a database. However, this example illustrates a situation in which we might need to update the value of a variable. The value of password was *qwerty1*, but we reassigned it to *qwerty2* which is the value JavaScript recognizes from that point on.\n\n## Naming Variables\n\nIn JavaScript, variable names are known as *identifiers*. Let’s take a look at some of the rules to follow when naming our variables:\n\n* Variable names can consist only of letters (a-z), numbers (0–9), dollar sign symbols ($), and underscores (_)\n* Variable names cannot contain any whitespace characters (tabs or spaces)\n* Numbers cannot begin the name of any variable\n* There are several [reserved keywords](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#Reserved_keywords_as_of_ECMAScript_2015) that cannot be used as the name of a variable\n* Variable names are case sensitive\n\nJavaScript also has the convention of using camel case (sometimes stylized as camelCase) in the names of functions and variables declared with var or let. This is the practice of writing the first word lowercase, and then capitalizing the first letter of every subsequent word with no spaces between them. Most variables that are not constants will follow this convention, with some exceptions. The names of variables that are constant, declared with the const keyword, are typically written in all uppercase.\n\nThis may seem like a lot of rules to learn, but it will very quickly become second nature to write valid and conventional variable names.\n\n## Difference Between var, let, and const\n\nJavaScript has three different keywords to declare a variable, which adds an extra layer of intricacy to the language. The differences between the three are based on scope, hoisting, and reassignment.\n\n![JavaScript Variable Comparison](/images/uploads/variables.png)\n\nSo which method is best? A commonly accepted practice is to use `const` as much as possible and `let` in the case of loops and reassignment. Generally, `var` can be avoided outside of working on legacy code.\n\n## Variable Scope\n\n*Scope* in JavaScript refers to the current context of code, which determines the accessibility of variables to JavaScript. The two types of scope are *local* and *global*:\n\n* **Global** variables are declared outside of a block\n* **Local** variables are declared inside of a block\n\nIn the example below, let’s create a global variable.\n\n```javascript\n// Initialize a global variable\n\nvar action= “run”;\n```\n\nWe learned that variables can be reassigned. Using local scope, we can actually create new variables with the same name as a variable in an outer scope without changing or reassigning the original value.\n\nIn the example below, we will create a global “action” variable. Within the function is a local variable with the same name. By sending them to the console, we can see how the variable’s value is different depending on the scope, and the original value is not changed.\n\n```javascript\n// Initialize a global variable\n\nvar action = “walk”;\n\nfunction hurry() {\n  // Initialize a local, function-scoped variable\n  var action = “run”;\n  console.log(action);\n}\n\n// Log the global and local variable\n\nconsole.log(action);\nhurry();\nconsole.log(action);\n\n// output:\nwalk\nrun\nwalk\n```\n\nIn this example, the local variable is *function-scoped*. Variables declared with the `var` keyword are always function-scoped, meaning they recognize functions as having a separate scope. This locally-scoped variable is therefore not accessible from the global scope.\n\nThe new keywords `let` and `const`, however, are block-scoped. This means that a new, local scope is created from any kind of block, including function blocks, if statements, and for and while loops.\n\nTo illustrate the difference between function- and block-scoped variables, we will assign a new variable in an if block using let.\n\n```javascript\nvar race = true;\n\n// Initialize a global variable\n\nlet action = “walk”;\n\nif (race) {\n  // Initialize a block-scoped variable\n  let action = “run”;\n  console.log(`It's a race! Let's ${action}.`);\n}\n\nconsole.log(`It's not a race. Let's ${action}.`);\n\n// output:\n\nIt's a race! Let's run.\nIt's not a race. Let's walk.\n```\n\nIn this example, the action variable has one value globally (walk), and another value locally (run). If we were to use `var`, however, there would be a different result.\n\n```javascript\n// Use var to initialize a variable\n\nvar action = “walk”;\n\nif (race) {\n  // Attempt to create a new variable in a block\n  var action = “run”;\n  console.log(`It's a race! Let's ${action}.`);\n}\n\nconsole.log(`It's not a race. Let's ${action}.`);\n\n// output:\n\nIt's a race! Let's run.\nIt's not a race. Let's run.\n```\n\nIn the result of this example, both the global variable and the block-scoped variable end up with the same value, **run**. This is because instead of creating a new local variable with `var`, you are reassigning the same variable in the same scope. `var` does not recognize `if` to be part of a different, new scope. It is generally recommended that you declare variables that are block-scoped, as they produce code that is less likely to unintentionally override variable values.\n\n## Hoisting\n\nIn most of the examples so far, we’ve used `var` to *declare* a variable, and we have *initialized* it with a value. After declaring and initializing, we can access or reassign the variable.\n\nIf we attempt to use a variable before it has been declared and initialized, it will return undefined.\n\n```javascript\n// Attempt to use a variable before declaring it\n\nconsole.log(x);\n\n// Variable assignment\n\nvar x = 100;\n\n// output:\n\nundefined\n```\n\nHowever, if we omit the `var` keyword, we are no longer declaring the variable, only initializing it. It will return a *ReferenceError* and halt the execution of the script.\n\n```javascript\n// Attempt to use a variable before declaring it\n\nconsole.log(x);\n\n// Variable assignment without var\n\nx = 100;\n\n// output:\n\nReferenceError: x is not defined\n```\n\nThe reason for this is due to *hoisting*, a behavior of JavaScript in which variable and function declarations are moved to the top of their scope. Since only the actual declaration is hoisted, not the initialization, the value in the first example returns undefined.\n\nTo demonstrate this concept more clearly, below is the code we wrote and how JavaScript actually interpreted it.\n\n```javascript\n// The code we wrote\n\nconsole.log(x);\nvar x = 100;\n\n// How JavaScript interpreted it\n\nvar x;\nconsole.log(x);\nx = 100;\n```\n\nJavaScript saved `x` to memory as a variable before the execution of the script. Since it was still called before it was defined, the result is `undefined` and not “100\". However, it does not cause a ReferenceError and halt the script.\n\nAlthough the `var` keyword did not actually change the location of the `var`, this is a helpful representation of how hoisting works. This behavior can cause issues, though, because the programmer who wrote this code likely expects the output of `x` to be true, when it is instead undefined.\n\nWe can also see how hoisting can lead to unpredictable results in the next example:\n\n```javascript\n// Initialize x in the global scope\n\nvar x = 100;\n\nfunction hoist() {\n  // A condition that should not affect the outcome of the code\n  if (false) {\n    var x = 200;\n  }\nconsole.log(x);\n}\n\nhoist();\n\n// output:\n\nundefined\n```\n\nIn this example, we declared `x` to be 100 globally. Depending on an if statement, `x` could change to 200, but since the condition was false it should not have affected the value of `x`. Instead, `x` was hoisted to the top of the `hoist()` function, and the value became undefined.\n\nThis type of unpredictable behavior can potentially cause bugs in a program. Since `let` and `const` are block-scoped, they will not hoist in this manner, as seen below.\n\n```javascript\n// Initialize x in the global scope\n\nlet x = true;\n\nfunction hoist() {\n  // Initialize x in the function scope\n  if (3 === 4) {\n    let x = false;\n  }\nconsole.log(x);\n}\n\nhoist();\n\n// output:\n\ntrue\n```\n\nDuplicate declaration of variables, which is possible with `var`, will throw an error with `let` and `const`.\n\n```javascript\n// Attempt to overwrite a variable declared with var\n\nvar x = 1;\nvar x = 2;\nconsole.log(x);\n\n// output:\n\n2\n\n// Attempt to overwrite a variable declared with let\n\nlet y = 1;\nlet y = 2;\nconsole.log(y);\n\n// output:\n\nUncaught SyntaxError: Identifier ‘y’ has already been declared\n```\n\nTo summarize, variables introduced with `var` have the potential of being affected by hoisting, a mechanism in JavaScript in which variable declarations are saved to memory. This may result in undefined variables in one’s code. The introduction of `let` and `const` resolves this issue by throwing an error when attempting to use a variable before declaring it or attempting to declare a variable more than once.\n\n## Constants\n\nMany programming languages feature *constants*, which are values that cannot be modified or changed. In JavaScript, the `const` identifier is modeled after constants, and the values assigned to a `const` cannot be reassigned.\n\nIt is a common convention to write all `const` identifiers in uppercase. This marks them as readily distinguishable from other variable values.\n\nIn the example below, we initialize the variable ACTION as a constant with the `const` keyword. Trying to reassign the variable will result in an error.\n\n```javascript\n// Assign value to const\n\nconst ACTION = “walk”;\n\n// Attempt to reassign value\n\nACTION = “run”;\nconsole.log(ACTION);\n\n// output:\n\nUncaught TypeError: Assignment to constant variable.\n```\n\nSince *`const`* values cannot be reassigned, they need to be declared and initialized at the same time, or will also throw an error.\n\n```javascript\n// Declare but do not initialize a const\n\nconst RACING;\nconsole.log(RACING);\n\n// output:\n\nUncaught SyntaxError: Missing initializer in const declaration\n```\n\nValues that cannot change in programming are known as *immutable*, while values that can be changed are *mutable*. Although `const` values cannot be reassigned, they are mutable as it is possible to modify the properties of objects declared with `const`.\n\n```javascript\n// Create a PERSON object with two properties\n\nconst PERSON = {\n  name: “Joanna”,\n  balance: 10000\n}\n\n// Modify a property of PERSON\n\nPERSON.balance = 15000;\nconsole.log(PERSON);\n\n// output:\n\n{ name: ‘Joanna’, price: 15000 }\n```\n\nConstants are useful for making it clear to your future self and other programmers working on a project with you that the intended variable should not be reassigned. If you expect that a variable may be modified in the future, you will likely want to use `let` to declare the variable instead.\n\n## Conclusion\n\nAnd that’s it! We’ve taken a look at what a variable is, the rules of naming a variable, and how to reassign variable values. We also learned about scope and hoisting, some of the limitations of the original `var` keyword, as well as how `let` and `const` resolve those issues.\n\n## Related Posts:\n\n* [An Introduction to the DOM](https://www.easeout.co/blog/2020-12-14-an-introduction-to-the-dom)\n* [Accessing DOM Elements](https://www.easeout.co/blog/2020-12-21-accessing-dom-elements)\n* [Traversing the DOM](https://www.easeout.co/blog/2020-12-28-traversing-the-dom/)",
  "title": "Understanding Variables, Scope and Hoisting",
  "description": "Learn about variables, scope and hoisting in JavaScript.",
  "short": "Learn about variables, scope and hoisting in JavaScript.",
  "category": "JavaScript"
}