{
  "date": "Wednesday August 11th, 2021",
  "dateshort": "August 11th",
  "body": "JavaScript classes we’re introduced with ECMAScript 2015, they’re often described as *syntactical sugar* over JavaScript’s existing structure of prototypical inheritance. So while classes *do not* introduce a new inheritance model to JavaScript — they do provide syntactical simplicity. This simplicity can help us produce less error-prone & more readable code.\n\n## Classes are just like functions!\n\nClasses are very similar to functions. Much like functions that have both function expressions and function declarations, classes have two components: **class expressions** and **class declarations**.\n\n## Class declarations\n\nLet's take a look at how we can define a class using a **class declaration**. We use the `class`keyword followed the name of the class:\n\n```\nclass Image {\n  constructor(height, width) {\n    this.height = height;\n    this.width = width;\n  }\n}\n```\n\n## Hoisting\n\nOne important difference between **function declarations** and **class declarations** is that function declarations are hoisted and class declarations are not. You first need to declare your class and then access it, otherwise, code like the following will throw a `ReferenceError`:\n\n```\nconst p = new Image(); // ReferenceError\n\nclass Image{}\n```\n\n## Class expressions\n\nA **class expression** is the other way to define a class. Class expressions can be named or unnamed. Note that the name given to a named class expression is local to the class’s body. (So it’s retrievable through the classes `name` property):\n\n```\n// An unnamed class expression\nlet Image = class {\n  constructor(height, width) {\n    this.height = height;\n    this.width = width;\n  }\n};\nconsole.log(Image.name);\n// output: \"Image\"\n\n// A named class expression\nlet MyImage = class Image {\n  constructor(height, width) {\n    this.height = height;\n    this.width = width;\n  }\n};\nconsole.log(MyImage.name);\n// output: \"Image\"\n```\n\n*Note:* Class **expressions** are subject to the same hoisting restrictions as described previously in the Class declarations section.\n\n## Constructors\n\nThe `constructor` method is a special method within JavaScript that we use to create and initialize an object created with a `class`. We can only use one method with the name \"constructor\" within a class.\n\nOur constructor can use the `super` keyword to call the constructor of the super class (more on this later in the article!).\n\n## Instance properties\n\nInstance properties must be defined inside of our class methods:\n\n```\nclass Image {\n  constructor(height, width) {    \n    this.height = height;\n    this.width = width;\n  }\n}\n```\n\nIf we wish to use static class-side properties and prototype data properties, these must be defined outside of the classes body declaration:\n\n```\nImage.staticWidth = 50;\nImage.prototype.prototypeWidth = 55;\n```\n\n## Field declarations\n\nWhilst the syntax is still considered experimental (*it’s not yet adopted by many browsers*), public and private field declarations are also worth knowing about — as often you’ll be developing with a Babel which will transpile the syntax for you.\n\n### Public field declarations\n\nLet’s revisit our example with the JavaScript field declaration syntax:\n\n```\nclass Image {\n  height = 0;\n  width;\n  constructor(height, width) {    \n    this.height = height;\n    this.width = width;\n  }\n}\n```\n\nThe difference is our fields have been declared up-front. So our class definitions become more self-documenting, and the fields are always present.\n\n*Note:* the fields can be declared with or without a default value!\n\n### Private field declarations\n\nWhen we use private fields, the definition can be refined like so:\n\n```\nclass Image {\n  #height = 0;\n  #width;\n  constructor(height, width) {    \n    this.#height = height;\n    this.#width = width;\n  }\n}\n```\n\nPrivate fields (declared with a `#`) cannot be referenced outside of the class, only within the class body. This ensures that your classes’ users can’t depend on internals, which may change with version changes.\n\nNote: Private fields cannot be created later through assignment. They can only be declared up-front in a field declaration.\n\n## Child classes using 'extends'\n\nWe can use the `extends` keyword with either class declarations or class expressions to create a class as a child of another class.\n\n```\nclass Vehicle{ \n  constructor(name) {\n    this.name = name;\n  }\n  \n  sound() {\n    console.log(`${this.name} makes a sound.`);\n  }\n}\nclass Car extends Vehicle{\n  constructor(name) {\n    super(name); // call the super class constructor and pass in the name parameter\n  }\n  sound() {\n    console.log(`The ${this.name} tooted its horn!`);\n  }\n}\nlet c = new Car('Volkswagen');\nc.sound(); // The Volkswagen tooted its horn!\n```\n\nIf there is a constructor present in the subclass, it needs to first call super() before using “this”.\n\nFunction-based “classes” may also be extended:\n\n```\nfunction Vehicle (name) {\n  this.name = name;  \n}\nVehicle.prototype.sound = function () {\n  console.log(`${this.name} makes a sound.`);\n}\nclass Car extends Vehicle{\n  speak() {\n    console.log(`The ${this.name} tooted its horn!`);\n  }\n}\nlet c = new Car('Volkswagen');\nc.sound(); // The Volkswagen tooted its horn!\n```\n\nNote: classes cannot extend regular objects! If you want to inherit from an object, use `Object.setPrototypeOf()`:\n\n```\nconst Vehicle = {\n  sound() {\n    console.log(`${this.name} makes a sound.`);\n  }\n};\n\nclass Car{\n  constructor(name) {\n    this.name = name;\n  }\n}\n\nlet c = new Car('Volkswagen');\nc.sound(); // Volkswagen makes a sound.\n```\n\n## Species\n\nIf you want to return `Array` objects from an array class `MyArray`. You can do so with the “species” pattern, which lets you override the default constructors.\n\nIf using methods such as `map()` it’ll return the default constructor. Then you’ll want these methods to return a parent `Array` object, instead of the `MyArray` object. `Symbol.species`lets you do this, like so:\n\n```\nclass MyArray extends Array {\n  // Overwrite species to the parent Array constructor\n  static get [Symbol.species]() { return Array; }\n}\n\nlet a = new MyArray(1,2,3);\nlet mapped = a.map(x => x * x);\n\nconsole.log(mapped instanceof MyArray); // false\nconsole.log(mapped instanceof Array);   // true\n```\n\n## The ‘Super’ keyword\n\nThe `super` keyword is used to call corresponding methods of super class. This is one advantage over prototype-based inheritance. Let’s see an example:\n\n```\nclass Volkswagen { \n  constructor(name) {\n    this.name = name;\n  }\n  \n  sound() {\n    console.log(`${this.name} makes a sound.`);\n  }\n}\n\nclass Beetle extends Volkswagen {\n  sound() {\n    super.sound();\n    console.log(`${this.name} toots it's horn.`);\n  }\n}\n\nlet b = new Beetle('Herbie');\nb.sound(); \n\n// Herbie makes a sound.\n// Herbie toots it's horn.\n```\n\n## Mix-ins\n\nMix-ins are templates for classes. An ECMAScript class can only have a single superclass, so multiple inheritance from tooling classes, for example, isn’t possible. The functionality must be provided by the superclass.\n\nA function with a superclass as input and a subclass extending that superclass as output can be used to implement mix-ins in ECMAScript:\n\n```\nlet calculatorMixin = Base => class extends Base {\n  calc() { }\n};\n\nlet randomizerMixin = Base => class extends Base {\n  randomize() { }\n};\n```\n\nA class that uses these mix-ins can then be written like this:\n\n```\nclass First { }\nclass Second extends calculatorMixin(randomizerMixin(First)) { ...\n```\n\nAnd that’s all for today! We’ve taken a deep dive into JavaScript classes including class declarations, class expressions, constructors, instance properties, field declarations, extends, species, super and mix-ins.\n\n### Related Posts:\n\n* [Understanding Variables, Scope and Hoisting](https://www.easeout.co/blog/2021-01-25-understanding-variables-scope-and-hoisting/)\n* [Working with Strings in JavaScript](easeout.co/blog/2020-11-23-working-with-strings-in-javascript/)\n* [JavaScript Data Type Conversion](https://www.easeout.co/blog/2020-11-05-javascript-data-type-conversion/)",
  "title": "What are classes?",
  "description": "What are classes in JavaScript?",
  "short": "What are classes in JavaScript?",
  "category": "JavaScript",
  "thumbnail": "/images/uploads/javascript-classes.png"
}